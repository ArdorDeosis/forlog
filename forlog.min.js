"use strict";function ForlogGrammar(){let n={};this.getRules=function(){return n};let t={};this.getVariables=function(){return t};let e={overrideRules:!1,keepVariables:!1,logToConsole:!0,errorReturnString:"ERROR"};this.getSettings=function(){return e};this.getVersion=function(){return"2.0"};let r={hasEnoughArguments:function(n,t,e){return!(e<t)||(i(`ERROR: not enough arguments in %c${n}%c command; expected ${t}, found ${e}`),!1)},isInt:function(n,t){return!isNaN(parseInt(t))||(i(`ERROR: argument '${t}' in %c${n}%c command is not a number`),!1)},isNonNegativeInt:function(n,t){return!(r.isInt(n,t)&&parseInt(t)<0)||(i(`ERROR: argument '${t}' in %c${n}%c command is not a number â‰¥ 0'`),!1)},isVariableName:function(n,t){return null!==t.match(/[a-z][A-Za-z0-9_$%&!?]*/)||(i(`ERROR: argument '${t}' in %c${n}%c command is not a valid variable name`),!1)}},l={set:function(n){return r.hasEnoughArguments("set",2,n.length)&&r.isVariableName("set",n[0])?(t[o(n[0])]=o(n[1]),""):e.errorReturnString},"set?":function(n){return r.hasEnoughArguments("set?",2,n.length)&&r.isVariableName("set?",n[0])?(t.hasOwnProperty(n[0])||(t[o(n[0])]=o(n[1])),""):e.errorReturnString},eq:function(n){return r.hasEnoughArguments("eq",3,n.length)?n[0]===n[1]?n[2]:n.length>3?n[3]:"":e.errorReturnString},lt:function(n){return r.hasEnoughArguments("lt",3,n.length)&&r.isInt("lt",n[0])&&r.isInt("lt",n[1])?parseInt(n[0])<parseInt(n[1])?n[2]:n.length>3?n[3]:"":e.errorReturnString},leq:function(n){return r.hasEnoughArguments("leq",3,n.length)&&r.isInt("leq",n[0])&&r.isInt("leq",n[1])?parseInt(n[0])<=parseInt(n[1])?n[2]:n.length>3?n[3]:"":e.errorReturnString},gt:function(n){return r.hasEnoughArguments("gt",3,n.length)&&r.isInt("gt",n[0])&&r.isInt("gt",n[1])?parseInt(n[0])>parseInt(n[1])?n[2]:n.length>3?n[3]:"":e.errorReturnString},geq:function(n){return r.hasEnoughArguments("geq",3,n.length)&&r.isInt("geq",n[0])&&r.isInt("geq",n[1])?parseInt(n[0])>=parseInt(n[1])?n[2]:n.length>3?n[3]:"":e.errorReturnString},for:function(n){return r.hasEnoughArguments("for",2,n.length)&&r.isNonNegativeInt("for",n[0])?Array(parseInt(n[0])).fill(n[1]).join(""):e.errorReturnString},rnd:function(n){return r.hasEnoughArguments("rnd",2,n.length)&&r.isInt("rnd",n[0])&&r.isInt("rnd",n[1])?e.errorReturnString:Math.floor(parseInt(n[0])+Math.random()*(parseInt(n[1])-parseInt(n[0])))}};function o(r){void 0===r&&(r="[START_SYMBOL]");let a=r.split(""),s="";for(;a.length>0;){let n=a.shift();s+="\\"===n?n+a.shift():"["===n?o(u()):"{"===n?o(g()):"<"===n?c():n}return s;function u(){let t=[],r="",l="",o=null;for(;a.length>0;){if(l+=o=a.shift(),""===r&&null!==o.match(/[A-Z]/)||""!==r&&null!==o.match(/[A-Za-z0-9_$%&!?]/))r+=o;else{if("|"!==o&&"]"!==o)return i(`ERROR: illegal character '${o}' in rule call`),e.errorReturnString;if(""===r)return i("ERROR: call to nameless Rule"),e.errorReturnString;if(!n.hasOwnProperty(r))return i(`ERROR: call to unknown Rule '${r}'`),e.errorReturnString;t=t.concat(n[r]),r=""}if("]"===o)return t.length<=0?(i(`ERROR: rule call produces no outcomes: ${"["+l}`),e.errorReturnString):t[Math.floor(Math.random()*t.length)]}}function g(){let n="",r=null;for(;a.length>0;){if(r=a.shift(),!(""===n&&null!==r.match(/[a-z]/)||""!==n&&null!==r.match(/[A-Za-z0-9_$%&!?]/)))return"}"===r?""===n?(i("ERROR: call to nameless Variable;"),e.errorReturnString):t.hasOwnProperty(n)?t[n]:(i(`ERROR: call to unknown Variable '${n}'`),e.errorReturnString):(i(`ERROR: illegal character '${r}' in variable call`),e.errorReturnString);n+=r}}function c(){let n=[""],t=0,e=null;for(;a.length>0;)if(e=a.shift(),r+=e,"<"===e)++t;else if(">"===e){if(--t<0)break}else 0===t&&"|"===e?n[n.length]="":n[n.length-1]+=e;let s=n.shift();if(""===s)i("ERROR: call to nameless command");else{if(l.hasOwnProperty(s)){for(let t=0;t<n.length;++t)"~"===n[t].charAt(0)?n[t]=n[t].substr(1,1/0):n[t]=o(n[t]);return o(l[s](n))}i(`ERROR: call to unknown command '${s}'`)}}}function i(n){if(!e.logToConsole)return;let t=(n.match(/%c/g)||[]).length,r=[n];for(let n=0;n<t;++n)r[n+1]=n%2==0?"font-style:italic;":"font-style:normal;";console.log.apply(null,r)}this.getCommands=function(){return l},this.parseGrammar=function(t){e.logToConsole&&console.groupCollapsed("compiling Forlog grammar");let r=0,l="START_SYMBOL",o=(t=t.replace(/\/\*[^]*?\*\//g,"")).split("\n");for(let t=0;t<o.length;++t){let a=o[t].replace(/\/\/.*$/,""),s=null;if(null===(s=a.match(/^[ \t]*([A-Z][A-Za-z0-9_$%&!?]*)[ \t]*$/)))if(null===(s=a.match(/^[ \t]*(?:#[ \t]*([0-9]*))?[ \t]*>(.*)$/)))null===(s=a.match(/^[ \t]*$/))&&(++r,i(`line ${t} can not be parsed and is ignored.\nLine ${t}: %c${a.substr(0,24)}${a.length>24?"...":""}`));else{let t=parseInt(s[1]);for(isNaN(t)&&(t=1),n.hasOwnProperty(l)||(n[l]=[]);t-- >0;)n[l][n[l].length]=s[2]}else l=s[1],e.overrideRules&&delete n[l]}i(`finished compiling; found ${r} unparseable lines`),e.logToConsole&&console.groupEnd()},this.process=function(n){return e.keepVariables||(t={}),function(n){return n=(n=n.replace(/\\n/g,"\n")).replace(/\\t/g,"\t")}(o(n))},this.addCommand=function(n,t){l[n]=t},this.changeSettings=function(n,t){let r={overrideRules:[!0,!1],keepVariables:[!0,!1],logToConsole:[!0,!1],errorReturnString:[]};r.hasOwnProperty(n)?r[n].length>0&&!r[n].includes(t)?i(`ERROR: '%c${t}%c' is not a valid value for setting '%c${n}%c'`):e[n]=t:i(`ERROR: there is no setting named '%c${n}%c'`)}}